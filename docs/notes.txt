OAuth 2.0 code api (plan)

/authorize <- send user here to for authentication
 -> post user&password to /login -> returns code
<- user is returned to client app

login.example.com <- send user here to authenticate
 -> post user&password to /login -> returns token
display user information and client and verify content send to client
 <- redirect back to client with code


/token <- request token with the code given
 -> return: access_token, token_type, expires_in

client sends token to /verify
 -> returns the content of the token 


New users:

/users
 -> / POST new user
 -> / GET list users (admin token only!)
 -> /:id PUT edit user
 -> /:id/password PATCH update password
 -> /:id DELETE delete user
 -> /:id GET display single user

/clients (admin token only!)
 -> / GET list clients
 -> / POST new client
 -> /:id PUT edit client
 -> /:id DELETE delete client


Request when requesting code:

GET /authorize?response_type=code&client_id=<client_id>&state=<state>&redirect_uri=<redirect_uri>(&resource=<resource_id>)&code_challenge=<PKCE_code_challenge>&code_challenge_method=S256
Host: auth.5v.fi

client_id = id of the client requesting code
state = random string that is returned with code (to prevent CSRF attacks)
redirect_uri = uri where user is returned with code (must match the uri registered with client!)
resource_id = not required for now
code_challenge = hashed random string, original is send with code in order to obtain token

Code response:

302 Found
Location: <redirect_uri>?code=<authorization_code>&state=<state>

authorization_code = code needed to obtain token
state = same string that was send with request

Requesting token:

POST /token
Host: auth.5v.fi
Content-Type: application/x-www-form-urlencoded

{
  grant_type=authorization_code
  code=<authorization_code>
  client_id=<client_id>
  code_verifier=<code_verifier>
  redirect_uri=<redirect_uri>
}

authorization_code = code received from /authorize 
client_id = id of the client requesting token
code_verifier = string that was used to create code_challenge
redirect_uri = uri that was used when the code was requested

Response (with token):

200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache
{
  access_token = <access_token>
  token_type = bearer
  expires_in = <token_expiration>
  (refresh_token = <refresh_token>)
}

access_token = token that can be used to access protected APIs
token_expiration = when token expires
refresh_token = token used to request new token (not implemented for now)